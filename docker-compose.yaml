version: "3.3"

services:
  traefik:
    image: 'traefik'
    volumes:
      - '/var/run/docker.sock:/var/run/docker.sock:ro'
      - './traefik/traefik.yaml:/etc/traefik/traefik.yaml:ro'
      - 'certs:/etc/traefik/acme'
      - './traefik/auth/basicauth.txt:/basicauth.txt'
    ports:
      - '${HTTP_PORT:-80}:80'
      - '${HTTPS_PORT:-443}:443'
    networks:
      - LTPipeline
    labels:
      - 'pipeline=${PIPELINE_NAME:-main}'
      - 'traefik.enable=true'
      - 'traefik.http.middlewares.basicauth.basicauth.usersFile=/basicauth.txt'
      # Traefik dashboard
      - 'traefik.http.routers.traefik.tls=true'
      - 'traefik.http.routers.traefik.tls.certresolver=letsencrypt'
      - 'traefik.http.routers.traefik.rule=Host(`${DOMAIN}`) && (PathPrefix(`/dashboard`) || PathPrefix(`/api`))'
      - 'traefik.http.routers.traefik.service=api@internal'
      - 'traefik.http.routers.traefik.middlewares=basicauth'
    restart: 'unless-stopped'

  dex:
    image: dexidp/dex
    user: 'root'
    env_file:
      ${DEX_FILES:-.}/dex.env
    environment:
      DEX_BASE_URL: "https://${DOMAIN_PORT:-${DOMAIN}}"
      TFA_CLIENT_SECRET: "${TFA_CLIENT_SECRET:-bar}"
    volumes:
      - ./traefik/auth/dex.yaml:/etc/dex/config.docker.yaml:ro
      #- ./traefik/auth/dex.db:/var/sqlite/dex.db
      - dex_data:/var/sqlite
    networks:
      - LTPipeline
    labels:
      - 'pipeline=${PIPELINE_NAME:-main}'
      - 'traefik.enable=true'
      - 'traefik.http.routers.dex.tls=true'
      - 'traefik.http.routers.dex.tls.certresolver=letsencrypt'
      - "traefik.http.routers.dex.rule=Host(`${DOMAIN}`) && PathPrefix(`/dex`)"
      - "traefik.http.routers.dex.entrypoints=https"
      - "traefik.http.services.dex.loadbalancer.server.port=5556"

  traefik-forward-auth:
    image: 'thomseddon/traefik-forward-auth:latest'
    depends_on:
      - traefik
      - dex
    command: '--config /auth-rules.ini'
    environment:
      LOG_LEVEL: 'debug'
      DEFAULT_PROVIDER: oidc
      SECRET: "${TFA_SIGNING_SECRET:-XFxy833ngUuK7BgIfIQcot3Jb3H8oHdXrCfTTBCne8E}"
      PROVIDERS_OIDC_CLIENT_ID: traefik-forward-auth
      PROVIDERS_OIDC_CLIENT_SECRET: "${TFA_CLIENT_SECRET:-bar}"
      PROVIDERS_OIDC_ISSUER_URL: 'https://${DOMAIN_PORT:-${DOMAIN}}/dex'
      LOGOUT_REDIRECT: 'https://${DOMAIN_PORT:-${DOMAIN}}/'
      LIFETIME: 604800
    volumes:
      - './traefik/auth/rules.ini:/auth-rules.ini:ro'
    networks:
      - LTPipeline
    labels:
      - 'pipeline=${PIPELINE_NAME:-main}'
      - 'traefik.enable=true'
      - 'traefik.http.middlewares.traefik-forward-auth.forwardauth.address=http://traefik-forward-auth:4181'
      - 'traefik.http.middlewares.traefik-forward-auth.forwardauth.authResponseHeaders=X-Forwarded-User'
      - 'traefik.http.services.traefik-forward-auth.loadbalancer.server.port=4181'
      - 'traefik.http.middlewares.logout.replacepathregex.regex=^/logout$$'
      - 'traefik.http.middlewares.logout.replacepathregex.replacement=/_oauth/logout'
    restart: 'unless-stopped'

  zookeeper:
    image: 'bitnami/zookeeper:latest'
    #ports:
    #  - '2181:2181'
    environment:
      - ALLOW_ANONYMOUS_LOGIN=yes
    networks:
      - LTPipeline
    restart: on-failure

  kafka:
    image: 'bitnamilegacy/kafka:3.9.0'
    ports:
      - '${MEDIATOR_PORT:-9093}:${MEDIATOR_PORT:-9093}'
    environment:
      - KAFKA_BROKER_ID=1
      - KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181
      - ALLOW_PLAINTEXT_LISTENER=yes
      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CLIENT:PLAINTEXT,EXTERNAL:PLAINTEXT
      - KAFKA_CFG_LISTENERS=CLIENT://:9092,EXTERNAL://:${MEDIATOR_PORT:-9093}
      - KAFKA_CFG_ADVERTISED_LISTENERS=CLIENT://kafka:9092,EXTERNAL://localhost:${MEDIATOR_PORT:-9093}
      - KAFKA_CFG_INTER_BROKER_LISTENER_NAME=CLIENT
      - KAFKA_ENABLE_KRAFT="false"
    depends_on:
     - zookeeper
    networks:
      - LTPipeline
    healthcheck:
        test: ["CMD-SHELL", "kafka-topics.sh --bootstrap-server localhost:9092 --list || exit 1"]
        interval: 5s
        timeout: 5s
        start_period: 5s
    restart: on-failure

  kafka_post_task:
    build: kafka_post_task
    depends_on:
      kafka:
        condition: service_healthy
    networks:
      - LTPipeline

  redis:
    image: redis
    volumes:
      - 'redis_data:/data'
    ports:
      - '${REDIS_PORT:-6379}:6379'
    networks:
      - LTPipeline
    restart: on-failure

  qbmediator:
    image: REPOSITORY:5000/qbmediator
    build: qbmediator
    depends_on:
      redis:
        condition: service_started
      kafka_post_task:
        condition: service_completed_successfully
    environment:
      - QUEUE_SYSTEM=${QUEUE_SYSTEM:-KAFKA}
    command: python -u mediator.py --queue-server kafka --queue-port 9092 --redis-server redis
    networks:
      - LTPipeline
    restart: on-failure

  streamingmt:
    image: REPOSITORY:5000/streamingmt
    build: streamingmt
    depends_on:
      - qbmediator
    environment:
      - QUEUE_SYSTEM=${QUEUE_SYSTEM:-KAFKA}
    command: python -u StreamMT.py --queue-server kafka --queue-port 9092 --redis-server redis --partitions 25
    networks:
      - LTPipeline
    restart: on-failure
    deploy:
        replicas: 25
  streamingtts:
    image: REPOSITORY:5000/streamingtts
    build: streamingtts
    depends_on:
      - qbmediator
    environment:
      - QUEUE_SYSTEM=${QUEUE_SYSTEM:-KAFKA}
    command: python -u StreamTTS.py --queue-server kafka --queue-port 9092 --redis-server redis --partitions 10
    networks:
      - LTPipeline
    restart: on-failure
    deploy:
        replicas: 10
# streaminglip:
#   image: REPOSITORY:5000/streaminglip
#   build: streaminglip
#   depends_on:
#     - qbmediator
#   environment:
#     - QUEUE_SYSTEM=${QUEUE_SYSTEM:-KAFKA}
#   command: python -u  StreamLipSync.py --queue-server kafka --queue-port 9092 --redis-server redis
#   networks:
#     - LTPipeline
#   restart: on-failure
  streamingasr:
    image: REPOSITORY:5000/streamingasr
    build: streamingasr
    depends_on:
      - qbmediator
    environment:
      - QUEUE_SYSTEM=${QUEUE_SYSTEM:-KAFKA}
    command: python -u StreamASR.py --queue-server kafka --queue-port 9092 --redis-server redis --partitions 25
    networks:
      - LTPipeline
    restart: on-failure
    deploy:
        replicas: 25
  streamingtextsegmenter:
    image: REPOSITORY:5000/streamingtextsegmenter
    build: streamingtextsegmenter
    depends_on:
      - qbmediator
    environment:
      - QUEUE_SYSTEM=${QUEUE_SYSTEM:-KAFKA}
    command: python -u StreamTextSegmenter.py --queue-server kafka --queue-port 9092 --redis-server redis
    networks:
      - LTPipeline
    restart: on-failure

  streamingtextstructurer:
    image: REPOSITORY:5000/streamingtextstructurer
    build:
      dockerfile: Dockerfile
      context: streamingtextstructurer
    environment:
      - QUEUE_SYSTEM=${QUEUE_SYSTEM:-KAFKA}
    command: python -u StreamTextStructurer.py --queue-server kafka --queue-port 9092 --redis-server redis --partitions 10
    networks:
      - LTPipeline
    restart: on-failure
    depends_on:
      - qbmediator
    deploy:
        replicas: 10
# streamingprep:
#   image: REPOSITORY:5000/streamingprep
#   build: streamingprep
#   depends_on:
#     - qbmediator
#   command: python -u StreamPrep.py --queue-server kafka --queue-port 9092 --redis-server redis
#   networks:
#     - LTPipeline
#   environment:
#     - QUEUE_SYSTEM=${QUEUE_SYSTEM:-KAFKA}
#     - DEBUG='False'
#   restart: on-failure
#   # volumes:
#   #   - /src/cache:/home/mtasr/LT2.0/ltpipeline/streamingprep/audio
  ltapi:
    image: REPOSITORY:5000/ltapi
    build: lt_api
    depends_on:
      - qbmediator
    environment:
      - QUEUE_SYSTEM=${QUEUE_SYSTEM:-KAFKA}
      - QUEUE_SERVER=kafka
      - QUEUE_PORT=9092
    networks:
      - LTPipeline
    labels:
      - 'pipeline=${PIPELINE_NAME:-main}'
      - 'traefik.enable=true'

      - 'traefik.http.services.ltapi.loadbalancer.server.port=5000'

      - 'traefik.http.routers.ltapi.tls=true'
      - 'traefik.http.routers.ltapi.tls.certresolver=letsencrypt'
      - 'traefik.http.routers.ltapi.rule=Host(`${DOMAIN}`) && PathPrefix(`/ltapi`)'
      - 'traefik.http.routers.ltapi.service=ltapi'
      - 'traefik.http.routers.ltapi.middlewares=basicauth'

      - 'traefik.http.routers.webapi.tls=true'
      - 'traefik.http.routers.webapi.tls.certresolver=letsencrypt'
      - 'traefik.http.routers.webapi.rule=Host(`${DOMAIN}`) && PathPrefix(`/webapi`)'
      - 'traefik.http.routers.webapi.service=ltapi'
      - 'traefik.http.routers.webapi.middlewares=webapi-compat,traefik-forward-auth'

      - 'traefik.http.middlewares.webapi-compat.replacepathregex.regex=^/webapi'
      - 'traefik.http.middlewares.webapi-compat.replacepathregex.replacement=/ltapi'
    restart: on-failure
  ltapi-stream:
    image: REPOSITORY:5000/ltapi-stream
    build: lt_api_stream
    depends_on:
      - qbmediator
    networks:
      - LTPipeline
    environment:
      - QUEUE_SYSTEM=${QUEUE_SYSTEM:-KAFKA}
    labels:
      - 'pipeline=${PIPELINE_NAME:-main}'
      - 'traefik.enable=true'

      - 'traefik.http.services.ltapi-stream.loadbalancer.server.port=5000'

      - 'traefik.http.routers.ltapi-stream.tls=true'
      - 'traefik.http.routers.ltapi-stream.tls.certresolver=letsencrypt'
      - 'traefik.http.routers.ltapi-stream.rule=Host(`${DOMAIN}`) && PathPrefix(`/ltapi/stream`)'
      - 'traefik.http.routers.ltapi-stream.service=ltapi-stream'
      - 'traefik.http.routers.ltapi-stream.middlewares=basicauth'

      - 'traefik.http.routers.webapi-stream.tls=true'
      - 'traefik.http.routers.webapi-stream.tls.certresolver=letsencrypt'
      - 'traefik.http.routers.webapi-stream.rule=Host(`${DOMAIN}`) && PathPrefix(`/webapi/stream`)'
      - 'traefik.http.routers.webapi-stream.service=ltapi-stream'
      - 'traefik.http.routers.webapi-stream.middlewares=webapi-compat,traefik-forward-auth'
    restart: on-failure

  log:
    image: REPOSITORY:5000/log
    build: loggingwoker
    depends_on:
      - qbmediator
    command: python -u logger.py --queue-server kafka --queue-port 9092 --redis-server redis --location /logs/
    networks:
      - LTPipeline
    environment:
      - QUEUE_SYSTEM=${QUEUE_SYSTEM:-KAFKA}
    restart: on-failure
    volumes:
      - logs:/logs
      - archive:/logs/archive

  frontend:
    image: REPOSITORY:5000/ltfrontend
    build: ltfrontend
    depends_on:
      - traefik
      - ltapi
      - ltapi-stream
    networks:
      - LTPipeline
    environment:
      QUEUE_SYSTEM: '${QUEUE_SYSTEM:-KAFKA}'
      API: 'http://ltapi:5000'
      API_STREAM: 'http://ltapi-stream:5000'
      API_EXTERNAL_HOST: '/webapi'
      ARCHIVE: 'http://archive:5000'
      THEME: '${FRONTEND_THEME:-default}'
      REDIS_HOST: 'redis'
      DOMAIN: '$DOMAIN'
    labels:
      - 'pipeline=${PIPELINE_NAME:-main}'
      - 'traefik.enable=true'
      - 'traefik.http.routers.frontend.tls=true'
      - 'traefik.http.routers.frontend.tls.certresolver=letsencrypt'
      - 'traefik.http.routers.frontend.rule=Host(`${DOMAIN}`)'
      - 'traefik.http.services.frontend.loadbalancer.server.port=5000'
      - 'traefik.http.routers.frontend.middlewares=logout,traefik-forward-auth'
      - 'autoheal-app=true'
    restart: on-failure

  archive:
    image: REPOSITORY:5000/lt-archive
    build: lt-archive
    networks:
      - LTPipeline
    environment:
      QUEUE_SYSTEM: '${QUEUE_SYSTEM:-KAFKA}'
      LT_ARCHIVE_DIR: '/data'
      REDIS_HOST: 'redis'
    volumes:
      - 'archive:/data'
    labels:
      - 'pipeline=${PIPELINE_NAME:-main}'
      - 'traefik.enable=true'
      - 'traefik.http.routers.archive.tls=true'
      - 'traefik.http.routers.archive.tls.certresolver=letsencrypt'
      - 'traefik.http.routers.archive.rule=Host(`${DOMAIN}`) && PathPrefix(`/ltarchive`)'
      - 'traefik.http.services.archive.loadbalancer.server.port=5000'
      - 'traefik.http.routers.archive.middlewares=traefik-forward-auth'
      - 'autoheal-app=true'
    restart: on-failure

  streamingsummarizer:
    image: REPOSITORY:5000/streamingsummarizer
    build:
      dockerfile: Dockerfile
      context: streamingsummarizer
    environment:
      - QUEUE_SYSTEM=${QUEUE_SYSTEM:-KAFKA}
    command: python -u StreamSummarizer.py --queue-server kafka --queue-port 9092 --redis-server redis
    networks:
      - LTPipeline
    restart: on-failure
    depends_on:
      - qbmediator
    deploy:
        replicas: 5
  streamingpostproduction:
    image: REPOSITORY:5000/streamingpostproduction
    build:
      dockerfile: Dockerfile
      context: streamingpostproduction
    environment:
      - QUEUE_SYSTEM=${QUEUE_SYSTEM:-KAFKA}
    command: python -u StreamPostProduction.py --queue-server kafka --queue-port 9092 --redis-server redis
    networks:
      - LTPipeline
    restart: on-failure
    depends_on:
      - qbmediator
    deploy:
        replicas: 5

  autoheal:
    image: willfarrell/autoheal:latest
    network_mode: none
    environment:
      AUTOHEAL_CONTAINER_LABEL: autoheal-app
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - /var/run/docker.sock:/var/run/docker.sock
    restart: always

  bot:
    image: REPOSITORY:5000/bot
    build:
      dockerfile: Dockerfile
      context: dialog/bot
    command: python -u server.py --queue-server kafka --queue-port 9092 --redis-server redis
    networks:
      - LTPipeline
    environment:
      - QUEUE_SYSTEM=${QUEUE_SYSTEM:-KAFKA}
      - DEBUG=True
    restart: on-failure
    depends_on:
      - qbmediator
    volumes:
      - archive:/logs/archive

networks:
  LTPipeline: {}
volumes:
  certs:
    name: 'certs'
  logs: {}
  archive: {}
  redis_data: {}
  mlflow_data: {}
  dex_data: {}
